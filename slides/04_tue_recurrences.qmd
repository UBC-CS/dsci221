---
title: "Solving Recurrences"
subtitle: "Week 4, Tuesday (Video)"
date: 2026-01-27
---

# Introduction

## What This Video Covers

On Monday, we saw recurrence forms and their solutions:

| Recurrence | Solution |
|------------|----------|
| $T(n) = T(n-1) + 1$ | $O(n)$ |
| $T(n) = T(n/2) + 1$ | $O(\log n)$ |
| $T(n) = 2T(n/2) + 1$ | $O(n)$ |
| $T(n) = 2T(n/2) + n$ | $O(n \log n)$ |
| $T(n) = T(n-1) + n$ | $O(n^2)$ |

Today: How do we **prove** these solutions?

## If You Took DSCI 220...

This material is review! Feel free to:

- Skim this video
- Skip to the merge sort proof at the end
- Use this as a refresher

## Two Methods

1. **Expansion method**: Unroll the recurrence, find the pattern, prove it

2. **Recursion tree method**: Visualize as a tree, sum the work

Both give the same answer. Choose whichever works for you!

# Method 1: Expansion

## The Idea

**Unroll** the recurrence step by step until you see a pattern.

Then **prove** the pattern is correct (usually by induction).

## Example 1: $T(n) = T(n-1) + c$

**Expand**:

$$T(n) = T(n-1) + c$$






## Example 2: $T(n) = T(n/2) + c$

**Expand** (assume $n = 2^k$ for simplicity):

$$T(n) = T(n/2) + c$$


## Example 3: $T(n) = 2T(n/2) + 1$

**Expand** (assume $n = 2^k$ for simplicity)::

$$T(n) = 2T(n/2) + 1$$



# Method 2: Recursion Trees

## The Idea

Draw the recursion as a **tree**:

- Each node represents work done at that call
- Children represent recursive calls
- **Sum all the nodes** to get total work

## Example: $T(n) = 2T(n/2) + cn$

```
Level 0:           [cn]                    → cn work
                  /   \
Level 1:       [cn/2] [cn/2]                → cn/2 + cn/2 = cn work
               /  \   /  \
Level 2:    [cn/4][cn/4][cn/4][cn/4]          → 4 × cn/4 = cn work
            ...
Level k:    [c] × n                       → n × c = cn work
```

## Analyzing the Tree

**Questions to answer**:

1. How much work at each level?
2. How many levels?
3. What's the total?

## For $T(n) = 2T(n/2) + n$

1. **Work at level $i$**: $n$ (it's the same at every level!)

2. **Number of levels**: $\log_2 n + 1$ (from $n$ down to $1$)

3. **Total work**: $n \times (\log n + 1) = O(n \log n)$ ✓

## Recursion Tree: $T(n) = 2T(n/2) + 1$

```
Level 0:           [1]                    → 1 work
                  /   \
Level 1:        [1]   [1]                 → 2 work
               /  \   /  \
Level 2:    [1] [1] [1] [1]               → 4 work
            ...
Level k:    [1] × n                       → n work
```

**Work at level $i$**: $2^i$


# The Merge Sort Proof

## The Recurrence

From Monday's lecture:

```python
def merge_sort(arr):
    if len(arr) <= 1:          # O(1)
        return arr
    mid = len(arr) // 2        # O(1)
    left = merge_sort(arr[:mid])    # T(n/2)
    right = merge_sort(arr[mid:])   # T(n/2)
    return merge(left, right)       # O(n)
```

$$T(n) = 2T(n/2) + cn, \quad T(1) = d$$


## The Formal Proof

**Claim**: $T(n) \leq cn\log n + dn$ for some constants $c,d > 0$ and all $n \geq 1$.

**Base case**: $T(1) = 

**Inductive step**: Assume $T(k) \leq ck\log k + dk$ for all $k < n$.

$$T(n) = 2T(n/2) + cn$$


# Summary

## Two Methods for Solving Recurrences

**Expansion method**:

1. Unroll step by step
2. Find the pattern
3. Sum the series

**Recursion tree method**:

1. Draw the tree
2. Calculate work at each level
3. Sum across all levels

## The Key Patterns

| Recurrence | Tree Shape | Solution |
|------------|-----------|----------|
| $T(n) = T(n-1) + 1$ | Linear chain | $O(n)$ |
| $T(n) = T(n/2) + 1$ | Short chain | $O(\log n)$ |
| $T(n) = 2T(n/2) + 1$ | Full tree, const work | $O(n)$ |
| $T(n) = 2T(n/2) + n$ | Full tree, linear work | $O(n \log n)$ |
| $T(n) = T(n-1) + n$ | Linear chain, linear work | $O(n^2)$ |


## What's Next

**Wednesday**: Can we do better than $O(n \log n)$ for sorting?


