---
title: "Introduction to Recursion"
subtitle: "Week 3, Wednesday"
date: 2026-01-22
---

# The 96 Days of DSCI 221

## ðŸŽµ On the ninety-sixth day... {.smaller}

96 moments of zen ðŸŽµ 95 grateful neurons ðŸŽµ 94 clever insights ðŸŽµ 93 aha moments ðŸŽµ 92 merge conflicts ðŸŽµ 91 Stack Overflow tabs ðŸŽµ 90 refactored functions ðŸŽµ 89 git commits ðŸŽµ 88 test cases ðŸŽµ 87 rubber ducks ðŸŽµ 86 coffee refills ðŸŽµ 85 keyboard clicks ðŸŽµ 84 documentation pages ðŸŽµ 83 variable names ðŸŽµ 82 edge cases ðŸŽµ 81 print statements ðŸŽµ 80 whiteboard markers ðŸŽµ 79 Piazza posts ðŸŽµ 78 recursive calls ðŸŽµ 77 helper functions ðŸŽµ 76 code reviews ðŸŽµ 75 unit tests ðŸŽµ 74 bug fixes ðŸŽµ 73 loop iterations ðŸŽµ 72 hash collisions ðŸŽµ 71 array indices ðŸŽµ 70 base cases ðŸŽµ 69 pointer errors ðŸŽµ 68 syntax errors ðŸŽµ 67 runtime exceptions ðŸŽµ 66 stack frames ðŸŽµ 65 heap allocations ðŸŽµ 64 binary digits ðŸŽµ 63 terminal commands ðŸŽµ 62 Slack messages ðŸŽµ 61 Discord pings ðŸŽµ 60 Zoom breakouts ðŸŽµ 59 office hours ðŸŽµ 58 study sessions ðŸŽµ 57 flashcards ðŸŽµ 56 practice problems ðŸŽµ 55 lecture notes ðŸŽµ 54 code snippets ðŸŽµ 53 TODO comments ðŸŽµ 52 FIXME tags ðŸŽµ 51 deprecation warnings ðŸŽµ 50 linter errors ðŸŽµ 49 type hints ðŸŽµ 48 docstrings ðŸŽµ 47 assert statements ðŸŽµ 46 boundary checks ðŸŽµ 45 null pointers ðŸŽµ 44 empty lists ðŸŽµ 43 off-by-ones ðŸŽµ 42 infinite loops ðŸŽµ 41 segfaults ðŸŽµ 40 memory leaks ðŸŽµ 39 cache misses ðŸŽµ 38 race conditions ðŸŽµ 37 deadlocks ðŸŽµ 36 timeouts ðŸŽµ 35 snack breaks ðŸŽµ 34 memes shared ðŸŽµ 33 playlists made ðŸŽµ 32 naps attempted ðŸŽµ 31 alarms snoozed ðŸŽµ 30 tabs still open ðŸŽµ 29 unread emails ðŸŽµ 28 doodles drawn ðŸŽµ 27 songs on repeat ðŸŽµ 26 empty notebooks ðŸŽµ 25 highlighters ðŸŽµ 24 sticky notes ðŸŽµ 23 "almost dones" ðŸŽµ 22 existential crises ðŸŽµ 21 snacks consumed ðŸŽµ 20 walks taken ðŸŽµ 19 deep breaths ðŸŽµ **18 pokemons** ðŸŽµ 17 demos ðŸŽµ 16 pull requests ðŸŽµ 15 code comments ðŸŽµ 14 merge commits ðŸŽµ 13 Piazza posts ðŸŽµ 12 cups of ramen ðŸŽµ 11 syntax errors ðŸŽµ 10 ChatGPT tabs ðŸŽµ 9 hours of sleep ðŸŽµ 8 TA office hours ðŸŽµ 7 Pomodoros ðŸŽµ 6 study rooms ðŸŽµ 5 passing tests ðŸŽµ 4 stretch breaks ðŸŽµ 3 docs read ðŸŽµ 2 good friends ðŸŽµ And a latte from Loafe.

## The Question

How many treats will you receive on the 96th day (Apr 10)?

$$1 + 2 + 3 + \ldots + 96 = \sum_{k=1}^{96} k = \text{ ?}$$

::: notes
You've seen the closed form: $\frac{n(n+1)}{2}$
:::

## Proving the Closed Form {.smaller}

**Claim**: $f(n) = \frac{n(n+1)}{2}$ where $f(n) = \sum_{k=1}^{n} k$

**Proof**: Consider an arbitrary $n >= 0$.  Then we have the following cases:

- **Case 1, $n = 0$** (base case): $f(0) = 0 = \frac{0 \cdot 1}{2}$ âœ“

- **Case 2, $n>0$** (inductive case):

Assume for any $0 < j < n$, $f(j) = \frac{j(j+1)}{2}$ (Inductive Hypothesis)

$f(n) = f(n-1) + n$ by definition.

$f(n-1) = \frac{(n-1)(n)}{2}$ by IH, since $n-1 < n$.

$f(n) = \frac{(n-1)(n)}{2} + n = \frac{(n)(n+1)}{2}$ by algebra. âœ“

:::{.notes}
"Notice: the inductive step assumes f(k) works and uses it. Just like recursion!"
:::

# Recursive Thinking

## The Recursive Structure: Peel Bottom Row

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 7))

n = 8
for row in range(n):
    for col in range(row + 1):
        if row == n - 1:  # Bottom row
            color = '#e74c3c'  # Red
        else:
            color = '#3498db'  # Blue
        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor=color, edgecolor='#2c3e50', linewidth=2)
        ax.add_patch(circle)

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title('f(n) = f(n-1) + n\nBlue: f(n-1)   Red: +n', fontsize=14)
plt.tight_layout()
plt.show()
```

:::{.notes}
"The triangle with n rows = the triangle with n-1 rows + n more dots on the bottom."
:::

## The Recursive Definition

A recursive mathematical function:

$$f(n) = \begin{cases} 0 & \text{if } n = 0 \\ f(n-1) + n & \text{if } n > 0 \end{cases}$$

:::{.notes}
"This is a recursive definition. The function is defined in terms of itself."
:::

## Induction = Recursion

| Induction | Math | Recursion |
|-----------|------|-----------|
| Consider arbitrary $n \geq 0$ | $n\in \mathbb{N}$ | `def f(n):` |
| Case $n = 0$: prove directly | $0$ if $n=0$ | `if n == 0: return 0` |
| Case $n > 0$: assume $P(j)$ for $j < n$ | $f(n-1)$ defined | Trust `f(n-1)` works |
| Prove $P(n)$ using IH | $f(n-1)+n$ if $n>0$ | Compute `f(n)` using `f(n-1)` |

**Same structure. Same reasoning.**

:::{.notes}
"If you can prove it by induction, you can compute it by recursion. They're the same thing."
:::



## The Recursive Code

Consider the math:

$$f(n) = \begin{cases} 0 & \text{if } n = 0 \\ f(n-1) + n & \text{if } n > 0 \end{cases}$$

```{pyodide}
def triangle(n):
    if n == 0:
        return 0
    return triangle(n - 1) + n
```


:::{.notes}
"The code is a direct translation of the math. Base case, recursive case."
:::

## Intuition for Recursive Design

When you write `triangle(n - 1)`, **trust that it works**.

This is exactly like relying on the **inductive hypothesis** in a proof.

Don't trace through every call. Just ask:

1. Does my base case return the right thing?
2. If `triangle(n-1)` magically gives me the right answer, does my code use it correctly?

:::{.notes}
"The recursion fairy handles the recursive call. You just handle your level. Same as induction: assume P(k) holds, prove P(k+1)."
:::

## The Three Musts of Recursion

For the recursion to work its magic, your code must satisfy:

1. **Handle all valid inputs**: Every input needs a case (base or recursive)

2. **Have a base case**: At least one case that returns without recursing

3. **Make progress**: Each recursive call must get closer to a base case

:::{.notes}
"These are the contract with the recursion fairy. Break any of these, and your code will loop forever or crash."
:::

## Same Triangle, Different View

What if we split the triangle differently?

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt

def draw_triangle_split(ax, n):
    half = n // 2
    top = n - half  # Size of square in middle

    for row in range(n):
        for col in range(row + 1):
            # Top triangle: first half rows
            if row < half:
                color = '#3498db'  # Blue - top triangle
            # Bottom section: split at column 'top'
            elif col < top:  # Left part is the square
                color = '#2ecc71'  # Green - square
            else:  # Right part is bottom triangle
                color = '#e74c3c'  # Red - bottom triangle

            circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                                facecolor=color, edgecolor='#2c3e50', linewidth=1.5)
            ax.add_patch(circle)

    # Add dividing lines
    ax.axhline(y=n - half, color='black', linewidth=2, linestyle='--')
    ax.axvline(x=top, ymin=0, ymax=half/n, color='black', linewidth=2, linestyle='--')

    ax.set_xlim(0, n)
    ax.set_ylim(0, n)
    ax.set_aspect('equal')
    ax.axis('off')

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

draw_triangle_split(ax1, 8)
ax1.set_title('Even: n = 8\nhalf = 4, square = 4Ã—4', fontsize=12)

draw_triangle_split(ax2, 7)
ax2.set_title('Odd: n = 7\nhalf = 3, square = 4Ã—4', fontsize=12)

plt.tight_layout()
plt.show()
```

## The Quadrant Decomposition

- **Blue**: Top triangle with $\lfloor n/2 \rfloor$ rows â†’ $f(\lfloor n/2 \rfloor)$ dots
- **Red**: Bottom-right triangle with $\lfloor n/2 \rfloor$ rows â†’ $f(\lfloor n/2 \rfloor)$ dots
- **Green**: Square of size $(n - \lfloor n/2 \rfloor)^2$ dots

$$f(n) = 2 \cdot f(\lfloor n/2 \rfloor) + (n - \lfloor n/2 \rfloor)^2$$

Works for **all** $n$. 

:::{.notes}
"Same problem, different recursive structure! The square absorbs the 'extra' row when n is odd."
:::

## Two Functions, Same Answer

I forgot to define `triangle_fast`!

```{pyodide}
def triangle(n):
    if n == 0:
        return 0
    return triangle(n - 1) + n

for n in [4, 5, 7, 8, 15, 16, 100]:
    slow = triangle(n)
    fast = triangle_fast(n)
    match = "âœ“" if slow == fast else "âœ—"
    print(f"n={n:3}: triangle={slow:5}, triangle_fast={fast:5} {match}")
```

## Which is Faster?

Both compute the same answer.

But the recursive structures are different:

- `triangle(n)`: calls `triangle(n-1)`
- `triangle_fast(n)`: calls `triangle_fast(n//2)`

Does that matter?

Let's race them!

## The Race

```{pyodide}
#| echo: false
import time
import sys
sys.setrecursionlimit(100000000)

def time_it(func, arg):
    start = time.time()
    func(arg)
    return time.time() - start
```

```{pyodide}
n = 50000
print(f"Racing on n = {n:,}")
print("-" * 40)

t1 = time_it(triangle, n)
print(f"triangle:      {t1:.4f}s")

t2 = time_it(triangle_fast, n)
print(f"triangle_fast: {t2:.6f}s")

print(f"\nSpeedup: {t1/t2:.0f}x faster!")
```

:::{.notes}
"Same answer. Wildly different performance. That's the power of choosing the right decomposition."
:::

## Why So Different?

**`triangle(n)`**: $f(n) = f(n-1) + n$

- Recursion depth: $n$
- Total calls: $n$

**`triangle_fast(n)`**: $f(n) = 2 \cdot f(n/2) + (n/2)^2$

- Recursion depth: $\log_2(n)$
- Total calls: $\log_2(n)$

:::{.notes}
"Linear depth vs logarithmic depth. At n=50000, that's 50000 vs ~16."
:::

## Big Idea: Recursion is About Decomposition

The same problem can have **multiple recursive structures**.

Different structures lead to **different code** and **different performance**.

This is the heart of **algorithm design**.

:::{.notes}
"This is why we study algorithms, not just 'how to code'. The structure matters."
:::


## What's Next

- **Lab 3**: Writing recursive functions
- **Week 4**: Analyzing recursive running times (recurrences)
- **Later**: Divide-and-conquer algorithms (merge sort, quicksort)

The triangle race was a preview: smart decomposition â†’ fast algorithms.

## Summary

1. **Recursion**: A function defined in terms of itself
2. **Base case**: When to stop
3. **Recursive case**: How to reduce the problem
4. **Key insight**: The same problem can have different recursive structures
5. **Performance**: Structure choice affects speed dramatically

## Questions?

