---
title: "Introduction to Recursion"
subtitle: "Week 3, Wednesday"
date: 2026-01-22
---

# The 96 Days of DSCI 221

## ðŸŽµ On the first day of DSCI... {.smaller}

*On the first day of DSCI, my prof gave to me...*

A latte from Loafe

## ðŸŽµ On the ninety-sixth day... {.smaller}

Ninety-six moments of zen,
Ninety-five grateful neurons,
...
Thirteen Piazza posts,
Twelve merge commits,
Eleven cups of ramen,
Ten syntax errors,
Nine ChatGPT tabs,
Eight hours of sleep,
Seven TA office hours,
Six Pomodoros,
**Five passing tests** ðŸŽµ
Four study rooms,
Three stretch breaks,
Two docs read,
And a latte from Loafe.

## The Question

After 96 days (Jan 5 â€“ Apr 10), how many treats did I receive **in total**?


Day 1: 1 treat

Day 2: 1 + 2 = 3 treats total

Day 3: 1 + 2 + 3 = 6 treats total

...

Day 96: 1 + 2 + 3 + ... + 96 = ?


**Nobody wants to compute that by hand.**

## The Sum

$$1 + 2 + 3 + \ldots + n = \sum_{k=1}^{n} k$$

For $n = 96$:

$$1 + 2 + 3 + \ldots + 96 = \text{???}$$

::: notes
You've seen the closed form: $\frac{n(n+1)}{2}$
:::

## Proving the Closed Form

**Claim**: $f(n) = \frac{n(n+1)}{2}$ where $f(n) \sum_{k=1}^{n} k$

We'll prove this by induction.

## Proof by Induction

Consider an arbitrary $n >= 0$.  Then we have the following cases:

**Case 1, $n = 0$** (base case): $f(0) = 0 = \frac{0 \cdot 1}{2}$ âœ“

**Case 2, $n>0$** (inductive case):

Assume for any $0 < j < n$, $f(j) = \frac{j(j+1)}{2}$ (Inductive Hypothesis)

$f(n) = f(n-1) + n$ by definition.
$f(n-1) = \frac{(n-1)(n)}{2}$ by IH, since $n-1 < n$.
$f(n) = \frac{(n-1)(n)}{2} + n = \frac{(n)(n+1)}{2}$ by algebra. âœ“

:::{.notes}
"Notice: the inductive step assumes f(k) works and uses it. Just like recursion!"
:::

# Recursive Thinking

## A Different Way to Think

How many gifts on day 13?


**Whatever I had on day 12, plus 13 more.**

$$f(13) = f(12) + 13$$

## The Recursive Definition

$$f(n) = \begin{cases} 0 & \text{if } n = 0 \\ f(n-1) + n & \text{if } n > 0 \end{cases}$$

**Base case**: $f(0) = 0$ (zero days = zero gifts)

**Recursive case**: $f(n) = f(n-1) + n$

:::{.notes}
"This is a recursive definition. The function is defined in terms of itself."
:::

## Induction = Recursion

| Induction | Recursion |
|-----------|-----------|
| Consider arbitrary $n \geq 0$ | `def f(n):` |
| Case $n = 0$: prove directly | `if n == 0: return 0` |
| Case $n > 0$: assume $P(j)$ for $j < n$ | Trust `f(n-1)` works |
| Prove $P(n)$ using IH | Compute `f(n)` using `f(n-1)` |

**Same structure. Same reasoning.**

:::{.notes}
"If you can prove it by induction, you can compute it by recursion. They're the same thing."
:::

# The Triangle

## Visualizing the Sum

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 7))

n = 8
for row in range(n):
    for col in range(row + 1):
        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor='#3498db', edgecolor='#2980b9', linewidth=2)
        ax.add_patch(circle)

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title(f'Triangle with n = {n} rows\nTotal dots = 1 + 2 + ... + 8 = 36', fontsize=14)
plt.tight_layout()
plt.show()
```

## The Recursive Structure: Peel Bottom Row

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 7))

n = 8
for row in range(n):
    for col in range(row + 1):
        if row == n - 1:  # Bottom row
            color = '#e74c3c'  # Red
        else:
            color = '#3498db'  # Blue
        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor=color, edgecolor='#2c3e50', linewidth=2)
        ax.add_patch(circle)

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title('f(n) = f(n-1) + n\nBlue: f(n-1)   Red: +n', fontsize=14)
plt.tight_layout()
plt.show()
```

:::{.notes}
"The triangle with n rows = the triangle with n-1 rows + n more dots on the bottom."
:::

## Peel Two Rows?

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 7))

n = 8
for row in range(n):
    for col in range(row + 1):
        if row >= n - 2:  # Bottom two rows
            color = '#e74c3c'  # Red
        else:
            color = '#3498db'  # Blue
        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor=color, edgecolor='#2c3e50', linewidth=2)
        ax.add_patch(circle)

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title('f(n) = f(n-2) + (n-1) + n\nBlue: f(n-2)   Red: +(n-1)+n', fontsize=14)
plt.tight_layout()
plt.show()
```

$$f(n) = f(n-2) + (n-1) + n$$

We can peel off any number of rows!

# From Math to Code

## The Recursive Code

```python
def triangle(n):
    if n == 0:
        return 0
    return triangle(n - 1) + n
```

Compare to the math:

$$f(n) = \begin{cases} 0 & \text{if } n = 0 \\ f(n-1) + n & \text{if } n > 0 \end{cases}$$

:::{.notes}
"The code is a direct translation of the math. Base case, recursive case."
:::

## Let's Run It

```{pyodide}
def triangle(n):
    if n == 0:
        return 0
    return triangle(n - 1) + n

print(f"triangle(5) = {triangle(5)}")
print(f"triangle(13) = {triangle(13)}")
```

## Trust the Recursion Fairy

When you write `triangle(n - 1)`, **trust that it works**.

This is exactly like relying on the **inductive hypothesis** in a proof.

Don't trace through every call. Just ask:

1. Does my base case return the right thing?
2. If `triangle(n-1)` magically gives me the right answer, does my code use it correctly?

:::{.notes}
"The recursion fairy handles the recursive call. You just handle your level. Same as induction: assume P(k) holds, prove P(k+1)."
:::

# A Different Decomposition

## Same Triangle, Different View

What if we split the triangle differently?

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt
import matplotlib.patches as patches

fig, ax = plt.subplots(figsize=(8, 6))

n = 8
half = n // 2

for row in range(n):
    for col in range(row + 1):
        # Determine which region: top-left triangle, bottom-left rect, bottom-right triangle
        if row < half:  # Top half
            color = '#3498db'  # Blue - top triangle
        elif col < half:  # Bottom-left
            color = '#2ecc71'  # Green - rectangle
        else:  # Bottom-right
            color = '#e74c3c'  # Red - bottom triangle

        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor=color, edgecolor='#2c3e50', linewidth=1.5)
        ax.add_patch(circle)

# Add dividing lines
ax.axhline(y=half, color='black', linewidth=2, linestyle='--')
ax.axvline(x=half, ymin=0, ymax=0.5, color='black', linewidth=2, linestyle='--')

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title('Split into quadrants (n = 8)', fontsize=14)
plt.tight_layout()
plt.show()
```

## The Quadrant Decomposition

For $n$ rows (where $n$ is even):

- **Blue**: Top triangle with $n/2$ rows â†’ $f(n/2)$ dots
- **Red**: Bottom-right triangle with $n/2$ rows â†’ $f(n/2)$ dots
- **Green**: Rectangle of size $(n/2) \times (n/2)$ â†’ $(n/2)^2$ dots

$$f(n) = 2 \cdot f(n/2) + (n/2)^2$$

:::{.notes}
"Same problem, different recursive structure!"
:::

## Split Anywhere!

```{python}
#| echo: false
#| fig-align: center
import matplotlib.pyplot as plt
import matplotlib.patches as patches

fig, ax = plt.subplots(figsize=(8, 7))

n = 8
k = 5  # Split at row 5

for row in range(n):
    for col in range(row + 1):
        if row < n - k:  # Top triangle (rows 0 to n-k-1)
            color = '#3498db'  # Blue - f(n-k)
        elif col < n - k:  # Middle-left rectangle
            color = '#2ecc71'  # Green - k*(n-k)
        else:  # Bottom-right triangle
            color = '#e74c3c'  # Red - f(k)

        circle = plt.Circle((col + 0.5, n - row - 0.5), 0.35,
                            facecolor=color, edgecolor='#2c3e50', linewidth=1.5)
        ax.add_patch(circle)

# Add dividing lines
ax.axhline(y=k, color='black', linewidth=2, linestyle='--')
ax.axvline(x=n-k, ymin=0, ymax=k/n, color='black', linewidth=2, linestyle='--')

ax.set_xlim(0, n)
ax.set_ylim(0, n)
ax.set_aspect('equal')
ax.axis('off')
plt.title('Split at any k (here k = 5)', fontsize=14)
plt.tight_layout()
plt.show()
```

## The General Decomposition

For any $0 < k < n$:

$$f(n) = f(n-k) + k \cdot (n-k) + f(k)$$

- **Blue**: Top triangle with $n-k$ rows â†’ $f(n-k)$ dots
- **Green**: Rectangle of size $k \times (n-k)$ â†’ $k(n-k)$ dots
- **Red**: Bottom-right triangle with $k$ rows â†’ $f(k)$ dots


**The insight**: There are infinitely many valid decompositions!

## But Wait... Base Cases?

With $f(n) = f(n-k) + k(n-k) + f(k)$ and $k = 5$:

- $f(8) = f(3) + 5 \cdot 3 + f(5)$
- $f(5) = f(0) + 5 \cdot 0 + f(5)$ ... infinite loop!


We need base cases for $f(0), f(1), \ldots, f(k)$.


**Lesson**: Your base cases must cover everything your recursion can reach.

:::{.notes}
"The quadrant decomposition (k = n/2) only needs f(0) and f(1). This k=5 split needs base cases for 0 through 5. More base cases = more work to verify."
:::

## The Divide-and-Conquer Code

```python
def triangle_fast(n):
    if n <= 1:
        return n
    half = n // 2
    return 2 * triangle_fast(half) + half * half
```


Does it compute the same thing?

```{pyodide}
def triangle_fast(n):
    if n <= 1:
        return n
    half = n // 2
    return 2 * triangle_fast(half) + half * half

print(f"triangle_fast(8) = {triangle_fast(8)}")
print(f"Expected: 1+2+...+8 = {8*9//2}")
```

## Two Functions, Same Answer

```{pyodide}
def triangle(n):
    if n == 0:
        return 0
    return triangle(n - 1) + n

def triangle_fast(n):
    if n <= 1:
        return n
    half = n // 2
    return 2 * triangle_fast(half) + half * half

for n in [4, 8, 16, 32, 64]:
    slow = triangle(n)
    fast = triangle_fast(n)
    match = "âœ“" if slow == fast else "âœ—"
    print(f"n={n:3}: triangle={slow:5}, triangle_fast={fast:5} {match}")
```

# The Race

## Which is Faster?

Both compute the same answer.

But the recursive structures are different:

- `triangle(n)`: makes $n$ recursive calls
- `triangle_fast(n)`: makes $\log_2(n)$ recursive calls


Let's race them!

## The Race

```{pyodide}
import sys
sys.setrecursionlimit(100000)

n = 50000
print(f"Racing on n = {n:,}")
print("-" * 40)

t1 = time_it(triangle, n)
print(f"triangle:      {t1:.4f}s")

t2 = time_it(triangle_fast, n)
print(f"triangle_fast: {t2:.6f}s")

print(f"\nSpeedup: {t1/t2:.0f}x faster!")
```

:::{.notes}
"Same answer. Wildly different performance. That's the power of choosing the right decomposition."
:::

## Why So Different?

**`triangle(n)`**: $f(n) = f(n-1) + n$

- Recursion depth: $n$
- Total calls: $n$

**`triangle_fast(n)`**: $f(n) = 2 \cdot f(n/2) + (n/2)^2$

- Recursion depth: $\log_2(n)$
- Total calls: $\log_2(n)$

:::{.notes}
"Linear depth vs logarithmic depth. At n=50000, that's 50000 vs ~16."
:::

# The Big Idea

## Recursion is About Decomposition

The same problem can have **multiple recursive structures**.

Different structures lead to **different code** and **different performance**.


This is the heart of **algorithm design**.

:::{.notes}
"This is why we study algorithms, not just 'how to code'. The structure matters."
:::

## The Connection to Induction

You already know recursion from math:

| Math (Induction) | Code (Recursion) |
|------------------|------------------|
| Consider arbitrary $n$ | `def f(n):` |
| Case $n = 0$ | `if n == 0: return ...` |
| Case $n > 0$: assume for $j < n$ | Trust recursive call |
| Prove for $n$ | Combine result with current |

:::{.notes}
"If you can prove it by induction, you can compute it by recursion."
:::

# Coming Up

## What's Next

- **Lab 3**: Writing recursive functions
- **Week 4**: Analyzing recursive running times (recurrences)
- **Later**: Divide-and-conquer algorithms (merge sort, quicksort)

The triangle race was a preview: smart decomposition â†’ fast algorithms.

## Summary

1. **Recursion**: A function defined in terms of itself
2. **Base case**: When to stop
3. **Recursive case**: How to reduce the problem
4. **Key insight**: The same problem can have different recursive structures
5. **Performance**: Structure choice affects speed dramatically

## Questions?

::: {.r-fit-text}
Two decompositions.

Same answer.

**Very** different performance.
:::
